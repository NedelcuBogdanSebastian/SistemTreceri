/*******************************************************************
 * 
 * Compute RMS voltage and phases of the signals.
 * Recompute after each Modbus interrogation.
 *
 * The MCP3903 ADC registers configuration is explained in the last function.
 *
 * The ADC sampling clock is derived from the TIM2_CH2 clock of 3 MHz:
 *
 *                        MCLK                    AMCLK                      DMCLK
 *     TIM2_CH2 ( 3 MHz ) ----> Prescaller ( /1 ) ----> Clock Divider ( /4 ) ---->
 *
 *     DMCLK                           DRCLK
 *     ----> OSR Clock Divider ( /64 ) ----> ADC sample frquency ( 11718.75 Hz )
 *
 *
 * Used pins:
 *
 *    PB11 ZERO-CROSS INPUT
 *
 *    PA1 - OSC1 3MHz (TIM2_CH2) ADC
 *    PA2 - USED TO CAPTURE /DRA FROM ADC
 *
 *    PA3 - CS SRAM
 *    PA4 - SS ADC
 *    PA5 - SCK ADC/SRAM
 *    PA6 - MISO ADC/SRAM
 *    PA7 - MOSI ADC/SRAM
 *
 *    RELAYS
 *    ------
 *    B12  -  K1
 *    B9   -  K2
 *    B13  -  K3
 *    B8   -  K4
 *    B14  -  K5
 *    B7   -  K6
 *    B15  -  K7
 *    B6   -  K8
 *
 *    B0   - SWITCH TO HIGH SIDE DP CHANELS (A,B,C)
 *    B1   - SWITCH TO LOW SIDE DP CHANELS (a,b,c)
 *
 *    If we need to store signed values we use 2's complement
 *    int16_t val = -100;
 *    uint16_t number = (uint16_t) val
 *
 *    The sampling frequency is:
 *        Fs = 11718.75  => we have data ready each 85.33uS
 *
 *    Number of samples is:
 *        num_points = 2048
 *
 *    How many samples we have in one period of 20 ms
 *        Fs / 50 Hz fundamental = 234.375 samples / period of 20 ms
 *
 *    How many periods we have in 2048 samples:
 *        num_points / 234.375 samples per period = 8.7381333 periods
 *
 *    FFT bin frequency:
 *        bin_freq = Fs / nsamples = 5.7220458984375 Hz/bin
 *
 *    Frequency bin near 50 Hz is at index 9 in FFT
 *        of frequency = bin_freq * 9 FFT bin = 51.4984130859375 Hz
 *
 *    The phase difference between the signal's true frequency (50 Hz) and the FFT bin 9
 *    frequency (51.4984 Hz) it will be calculated and substracted from the phase.
 *
 *    The difference in angular frequency is:
 *        delta_phase = 2PI × (fbin - fsignal) = 2PI × (51.4984130859375 - 50) = 2PI × 1.4984130859375 = 9.4148 rad/s
 *
 *    The FFT gives us the phase at bin 9 for the frequency 51.4984 Hz, the signal at 50 Hz will
 *    have advanced by a phase difference during the length of the signal.
 *
 *    Let T be the total duration of the signal:
 *        T = num_points / sample_rate = 2048 / 11718.75 = 0.174762666 seconds
 *
 *    The total phase shift over this time T is:
 *        phase_difference = delta_phase × T = 9.4148 × 0.174762666 = 1.646 rad = 94.272°
 *
 *    So, the phase at bin 9 is approximately 94.272° ahead of the true phase at 50 Hz.
 *
 ********************************************************************/

#include "stm32f10x.h"
#include "math.h"
#include "main.h"
#include "mbutils.h"
#include "mb.h"

// Flattop Window: If the purpose of the test focus more on the energy value of a
// certain periodic signal frequency point. For example for Upeak, Upeak-peak, Urms,
// then the accuracy of its amplitude is more important, and a window with slighty
// wider lobes is better.
// The Flat Top window has a flatter passband, which helps retain accurate amplitude
// and phase information, particularly when analyzing signals where frequency peaks
// must be well-isolated. Since the window decreases the leakage, the phase extraction
// becomes more accurate. However, keep in mind that this window broadens the peaks,
// so you might sacrifice some resolution in the frequency domain.
/*void generate_flat_top_window(float *window, size_t num_points) {
    // Flat Top window coefficients
    const float a0 = 1.0;
    const float a1 = 1.93;
    const float a2 = 1.29;
    const float a3 = 0.388;
    const float a4 = 0.028;

    for (size_t n = 0; n < num_points; n++) {
        // Compute the normalized index value
        float factor = (2 * PI * n) / (num_points - 1);

        // Apply the Flat Top window function
        window[n] = a0
                  - a1 * cos(factor)
                  + a2 * cos(2 * factor)
                  - a3 * cos(3 * factor)
                  + a4 * cos(4 * factor);
    }
}
*/
const float flattop_window[] = {
0.000000, -0.000001, -0.000004, -0.000008, -0.000014, -0.000022, -0.000032, -0.000043,
-0.000056, -0.000071, -0.000088, -0.000106, -0.000127, -0.000149, -0.000173, -0.000198,
-0.000226, -0.000255, -0.000286, -0.000319, -0.000354, -0.000390, -0.000429, -0.000469,
-0.000511, -0.000556, -0.000602, -0.000650, -0.000700, -0.000751, -0.000805, -0.000861,
-0.000919, -0.000978, -0.001040, -0.001104, -0.001170, -0.001238, -0.001308, -0.001380,
-0.001454, -0.001530, -0.001609, -0.001690, -0.001773, -0.001858, -0.001945, -0.002035,
-0.002127, -0.002221, -0.002317, -0.002416, -0.002517, -0.002621, -0.002727, -0.002836,
-0.002947, -0.003060, -0.003176, -0.003295, -0.003416, -0.003539, -0.003666, -0.003795,
-0.003926, -0.004061, -0.004198, -0.004338, -0.004480, -0.004626, -0.004774, -0.004926,
-0.005080, -0.005237, -0.005397, -0.005560, -0.005726, -0.005896, -0.006068, -0.006243,
-0.006422, -0.006604, -0.006789, -0.006977, -0.007169, -0.007364, -0.007562, -0.007764,
-0.007969, -0.008178, -0.008390, -0.008606, -0.008826, -0.009048, -0.009275, -0.009505,
-0.009740, -0.009977, -0.010219, -0.010465, -0.010714, -0.010967, -0.011224, -0.011486,
-0.011751, -0.012020, -0.012294, -0.012571, -0.012853, -0.013139, -0.013429, -0.013724,
-0.014022, -0.014326, -0.014633, -0.014945, -0.015262, -0.015583, -0.015908, -0.016239,
-0.016574, -0.016913, -0.017257, -0.017606, -0.017960, -0.018319, -0.018683, -0.019051,
-0.019424, -0.019803, -0.020186, -0.020575, -0.020968, -0.021367, -0.021771, -0.022180,
-0.022594, -0.023014, -0.023439, -0.023869, -0.024305, -0.024746, -0.025193, -0.025645,
-0.026103, -0.026567, -0.027036, -0.027510, -0.027991, -0.028477, -0.028968, -0.029466,
-0.029970, -0.030479, -0.030994, -0.031515, -0.032042, -0.032576, -0.033115, -0.033660,
-0.034212, -0.034769, -0.035333, -0.035903, -0.036479, -0.037061, -0.037650, -0.038245,
-0.038846, -0.039454, -0.040068, -0.040688, -0.041315, -0.041949, -0.042589, -0.043235,
-0.043888, -0.044548, -0.045215, -0.045887, -0.046567, -0.047253, -0.047946, -0.048646,
-0.049353, -0.050066, -0.050786, -0.051513, -0.052247, -0.052987, -0.053735, -0.054489,
-0.055250, -0.056018, -0.056794, -0.057576, -0.058365, -0.059161, -0.059964, -0.060774,
-0.061591, -0.062415, -0.063246, -0.064084, -0.064929, -0.065781, -0.066640, -0.067507,
-0.068380, -0.069261, -0.070148, -0.071043, -0.071945, -0.072854, -0.073770, -0.074693,
-0.075623, -0.076560, -0.077504, -0.078456, -0.079414, -0.080380, -0.081352, -0.082332,
-0.083319, -0.084312, -0.085313, -0.086321, -0.087336, -0.088357, -0.089386, -0.090422,
-0.091464, -0.092514, -0.093570, -0.094634, -0.095704, -0.096781, -0.097865, -0.098956,
-0.100053, -0.101157, -0.102268, -0.103386, -0.104510, -0.105641, -0.106779, -0.107923,
-0.109073, -0.110230, -0.111394, -0.112564, -0.113740, -0.114923, -0.116112, -0.117308,
-0.118509, -0.119717, -0.120931, -0.122151, -0.123377, -0.124609, -0.125847, -0.127090,
-0.128340, -0.129595, -0.130857, -0.132123, -0.133396, -0.134674, -0.135957, -0.137246,
-0.138541, -0.139840, -0.141145, -0.142455, -0.143770, -0.145090, -0.146415, -0.147745,
-0.149080, -0.150419, -0.151763, -0.153112, -0.154465, -0.155823, -0.157185, -0.158551,
-0.159922, -0.161296, -0.162675, -0.164057, -0.165443, -0.166833, -0.168227, -0.169624,
-0.171024, -0.172428, -0.173835, -0.175246, -0.176659, -0.178075, -0.179494, -0.180916,
-0.182341, -0.183767, -0.185197, -0.186628, -0.188062, -0.189498, -0.190936, -0.192375,
-0.193817, -0.195259, -0.196704, -0.198149, -0.199596, -0.201044, -0.202493, -0.203943,
-0.205393, -0.206844, -0.208295, -0.209747, -0.211199, -0.212651, -0.214102, -0.215554,
-0.217005, -0.218455, -0.219905, -0.221354, -0.222802, -0.224248, -0.225694, -0.227138,
-0.228580, -0.230020, -0.231459, -0.232895, -0.234330, -0.235762, -0.237191, -0.238617,
-0.240041, -0.241461, -0.242879, -0.244292, -0.245703, -0.247109, -0.248512, -0.249910,
-0.251304, -0.252694, -0.254078, -0.255459, -0.256834, -0.258203, -0.259568, -0.260927,
-0.262280, -0.263627, -0.264967, -0.266302, -0.267630, -0.268951, -0.270265, -0.271572,
-0.272872, -0.274164, -0.275449, -0.276725, -0.277993, -0.279253, -0.280504, -0.281747,
-0.282980, -0.284204, -0.285419, -0.286624, -0.287819, -0.289004, -0.290179, -0.291343,
-0.292497, -0.293639, -0.294771, -0.295891, -0.296999, -0.298095, -0.299179, -0.300251,
-0.301311, -0.302357, -0.303391, -0.304411, -0.305417, -0.306410, -0.307389, -0.308354,
-0.309304, -0.310240, -0.311160, -0.312065, -0.312955, -0.313830, -0.314688, -0.315530,
-0.316356, -0.317165, -0.317957, -0.318732, -0.319489, -0.320229, -0.320951, -0.321654,
-0.322340, -0.323006, -0.323654, -0.324282, -0.324891, -0.325480, -0.326049, -0.326598,
-0.327126, -0.327634, -0.328120, -0.328585, -0.329029, -0.329451, -0.329850, -0.330228,
-0.330582, -0.330914, -0.331222, -0.331508, -0.331769, -0.332006, -0.332219, -0.332408,
-0.332572, -0.332710, -0.332824, -0.332912, -0.332973, -0.333009, -0.333018, -0.333001,
-0.332957, -0.332885, -0.332786, -0.332659, -0.332504, -0.332320, -0.332108, -0.331867,
-0.331597, -0.331297, -0.330968, -0.330608, -0.330218, -0.329798, -0.329347, -0.328865,
-0.328351, -0.327806, -0.327228, -0.326619, -0.325977, -0.325302, -0.324594, -0.323853,
-0.323078, -0.322270, -0.321427, -0.320549, -0.319637, -0.318690, -0.317708, -0.316690,
-0.315637, -0.314547, -0.313421, -0.312259, -0.311059, -0.309822, -0.308548, -0.307236,
-0.305887, -0.304499, -0.303072, -0.301607, -0.300102, -0.298559, -0.296975, -0.295352,
-0.293689, -0.291985, -0.290241, -0.288456, -0.286630, -0.284762, -0.282853, -0.280901,
-0.278908, -0.276872, -0.274793, -0.272672, -0.270507, -0.268299, -0.266047, -0.263751,
-0.261411, -0.259026, -0.256597, -0.254123, -0.251603, -0.249038, -0.246428, -0.243771,
-0.241069, -0.238320, -0.235524, -0.232682, -0.229792, -0.226855, -0.223871, -0.220839,
-0.217758, -0.214630, -0.211453, -0.208227, -0.204953, -0.201629, -0.198256, -0.194834,
-0.191361, -0.187839, -0.184267, -0.180644, -0.176970, -0.173246, -0.169471, -0.165645,
-0.161767, -0.157837, -0.153856, -0.149823, -0.145737, -0.141600, -0.137409, -0.133166,
-0.128870, -0.124521, -0.120119, -0.115663, -0.111153, -0.106590, -0.101973, -0.097302,
-0.092576, -0.087796, -0.082961, -0.078072, -0.073127, -0.068128, -0.063073, -0.057963,
-0.052797, -0.047576, -0.042299, -0.036966, -0.031577, -0.026132, -0.020630, -0.015072,
-0.009458, -0.003786, 0.001942, 0.007727, 0.013569, 0.019468, 0.025424, 0.031438,
0.037510, 0.043638, 0.049825, 0.056069, 0.062371, 0.068731, 0.075149, 0.081625,
0.088159, 0.094752, 0.101402, 0.108111, 0.114879, 0.121705, 0.128589, 0.135532,
0.142534, 0.149595, 0.156714, 0.163892, 0.171129, 0.178425, 0.185779, 0.193193,
0.200665, 0.208197, 0.215787, 0.223436, 0.231145, 0.238912, 0.246739, 0.254624,
0.262569, 0.270572, 0.278635, 0.286756, 0.294937, 0.303176, 0.311475, 0.319832,
0.328248, 0.336723, 0.345257, 0.353850, 0.362501, 0.371211, 0.379980, 0.388807,
0.397692, 0.406636, 0.415639, 0.424699, 0.433818, 0.442995, 0.452230, 0.461523,
0.470875, 0.480283, 0.489750, 0.499273, 0.508855, 0.518494, 0.528190, 0.537943,
0.547754, 0.557621, 0.567545, 0.577525, 0.587562, 0.597655, 0.607805, 0.618011,
0.628272, 0.638590, 0.648962, 0.659391, 0.669875, 0.680413, 0.691007, 0.701656,
0.712358, 0.723115, 0.733927, 0.744793, 0.755712, 0.766684, 0.777710, 0.788790,
0.799922, 0.811107, 0.822344, 0.833634, 0.844976, 0.856369, 0.867814, 0.879311,
0.890859, 0.902457, 0.914105, 0.925805, 0.937555, 0.949353, 0.961202, 0.973100,
0.985047, 0.997042, 1.009086, 1.021178, 1.033318, 1.045505, 1.057739, 1.070021,
1.082349, 1.094723, 1.107143, 1.119610, 1.132121, 1.144677, 1.157277, 1.169923,
1.182612, 1.195345, 1.208121, 1.220940, 1.233802, 1.246705, 1.259651, 1.272639,
1.285667, 1.298735, 1.311845, 1.324995, 1.338184, 1.351411, 1.364678, 1.377985,
1.391328, 1.404709, 1.418127, 1.431583, 1.445074, 1.458601, 1.472164, 1.485763,
1.499395, 1.513062, 1.526763, 1.540498, 1.554265, 1.568065, 1.581897, 1.595761,
1.609656, 1.623581, 1.637536, 1.651522, 1.665537, 1.679580, 1.693652, 1.707752,
1.721879, 1.736033, 1.750213, 1.764421, 1.778652, 1.792909, 1.807190, 1.821496,
1.835824, 1.850176, 1.864549, 1.878946, 1.893363, 1.907801, 1.922259, 1.936739,
1.951236, 1.965752, 1.980287, 1.994840, 2.009409, 2.023995, 2.038597, 2.053216,
2.067848, 2.082494, 2.097155, 2.111830, 2.126517, 2.141216, 2.155927, 2.170649,
2.185381, 2.200124, 2.214875, 2.229636, 2.244405, 2.259180, 2.273963, 2.288754,
2.303549, 2.318350, 2.333155, 2.347965, 2.362778, 2.377594, 2.392412, 2.407233,
2.422054, 2.436875, 2.451696, 2.466518, 2.481338, 2.496155, 2.510970, 2.525782,
2.540590, 2.555394, 2.570192, 2.584986, 2.599773, 2.614553, 2.629325, 2.644091,
2.658846, 2.673593, 2.688329, 2.703056, 2.717770, 2.732473, 2.747163, 2.761841,
2.776504, 2.791153, 2.805787, 2.820406, 2.835008, 2.849594, 2.864161, 2.878711,
2.893242, 2.907753, 2.922244, 2.936715, 2.951164, 2.965591, 2.979995, 2.994377,
3.008734, 3.023066, 3.037373, 3.051656, 3.065910, 3.080138, 3.094338, 3.108510,
3.122652, 3.136765, 3.150847, 3.164900, 3.178919, 3.192907, 3.206861, 3.220783,
3.234670, 3.248522, 3.262338, 3.276120, 3.289863, 3.303570, 3.317238, 3.330869,
3.344459, 3.358010, 3.371520, 3.384990, 3.398417, 3.411801, 3.425143, 3.438442,
3.451695, 3.464904, 3.478067, 3.491185, 3.504256, 3.517278, 3.530253, 3.543180,
3.556057, 3.568884, 3.581661, 3.594387, 3.607061, 3.619683, 3.632251, 3.644767,
3.657228, 3.669635, 3.681986, 3.694282, 3.706520, 3.718702, 3.730826, 3.742892,
3.754899, 3.766846, 3.778733, 3.790561, 3.802327, 3.814030, 3.825672, 3.837251,
3.848767, 3.860218, 3.871604, 3.882927, 3.894182, 3.905372, 3.916495, 3.927551,
3.938539, 3.949458, 3.960308, 3.971089, 3.981800, 3.992440, 4.003008, 4.013506,
4.023932, 4.034284, 4.044563, 4.054770, 4.064901, 4.074957, 4.084939, 4.094845,
4.104675, 4.114428, 4.124104, 4.133702, 4.143222, 4.152663, 4.162025, 4.171308,
4.180511, 4.189632, 4.198673, 4.207633, 4.216511, 4.225306, 4.234018, 4.242648,
4.251194, 4.259655, 4.268032, 4.276325, 4.284532, 4.292652, 4.300687, 4.308636,
4.316496, 4.324270, 4.331956, 4.339554, 4.347063, 4.354483, 4.361814, 4.369055,
4.376205, 4.383266, 4.390235, 4.397114, 4.403901, 4.410596, 4.417198, 4.423709,
4.430126, 4.436450, 4.442680, 4.448817, 4.454859, 4.460807, 4.466660, 4.472418,
4.478080, 4.483647, 4.489118, 4.494492, 4.499770, 4.504951, 4.510035, 4.515021,
4.519910, 4.524701, 4.529394, 4.533989, 4.538485, 4.542882, 4.547180, 4.551379,
4.555478, 4.559477, 4.563377, 4.567176, 4.570876, 4.574474, 4.577972, 4.581369,
4.584665, 4.587860, 4.590952, 4.593945, 4.596834, 4.599622, 4.602308, 4.604892,
4.607374, 4.609753, 4.612030, 4.614204, 4.616275, 4.618243, 4.620108, 4.621871,
4.623529, 4.625085, 4.626538, 4.627887, 4.629132, 4.630274, 4.631312, 4.632247,
4.633078, 4.633805, 4.634429, 4.634948, 4.635364, 4.635675, 4.635883, 4.635987,
4.635987, 4.635883, 4.635675, 4.635364, 4.634948, 4.634429, 4.633805, 4.633078,
4.632247, 4.631312, 4.630274, 4.629132, 4.627887, 4.626538, 4.625085, 4.623529,
4.621871, 4.620108, 4.618243, 4.616275, 4.614203, 4.612030, 4.609753, 4.607374,
4.604892, 4.602308, 4.599622, 4.596834, 4.593944, 4.590953, 4.587860, 4.584665,
4.581369, 4.577972, 4.574474, 4.570876, 4.567176, 4.563377, 4.559477, 4.555478,
4.551379, 4.547180, 4.542882, 4.538485, 4.533989, 4.529394, 4.524702, 4.519910,
4.515021, 4.510035, 4.504951, 4.499770, 4.494492, 4.489118, 4.483647, 4.478080,
4.472417, 4.466660, 4.460807, 4.454859, 4.448817, 4.442680, 4.436450, 4.430126,
4.423708, 4.417199, 4.410596, 4.403901, 4.397114, 4.390235, 4.383266, 4.376206,
4.369054, 4.361814, 4.354483, 4.347063, 4.339553, 4.331956, 4.324270, 4.316497,
4.308635, 4.300687, 4.292653, 4.284532, 4.276324, 4.268033, 4.259655, 4.251194,
4.242648, 4.234019, 4.225306, 4.216511, 4.207633, 4.198673, 4.189632, 4.180511,
4.171308, 4.162025, 4.152663, 4.143222, 4.133701, 4.124104, 4.114428, 4.104675,
4.094845, 4.084939, 4.074958, 4.064901, 4.054769, 4.044563, 4.034284, 4.023932,
4.013506, 4.003009, 3.992440, 3.981800, 3.971088, 3.960308, 3.949458, 3.938539,
3.927550, 3.916495, 3.905372, 3.894183, 3.882926, 3.871605, 3.860218, 3.848767,
3.837251, 3.825672, 3.814031, 3.802327, 3.790560, 3.778734, 3.766846, 3.754899,
3.742892, 3.730826, 3.718702, 3.706521, 3.694281, 3.681986, 3.669635, 3.657229,
3.644767, 3.632252, 3.619683, 3.607061, 3.594387, 3.581661, 3.568885, 3.556057,
3.543180, 3.530253, 3.517278, 3.504256, 3.491184, 3.478067, 3.464904, 3.451696,
3.438441, 3.425143, 3.411801, 3.398417, 3.384989, 3.371520, 3.358010, 3.344459,
3.330868, 3.317238, 3.303570, 3.289864, 3.276119, 3.262339, 3.248522, 3.234670,
3.220782, 3.206861, 3.192907, 3.178920, 3.164899, 3.150847, 3.136765, 3.122653,
3.108509, 3.094338, 3.080138, 3.065911, 3.051655, 3.037374, 3.023066, 3.008734,
2.994376, 2.979995, 2.965591, 2.951164, 2.936714, 2.922244, 2.907753, 2.893242,
2.878711, 2.864161, 2.849594, 2.835009, 2.820406, 2.805787, 2.791153, 2.776505,
2.761840, 2.747163, 2.732473, 2.717771, 2.703055, 2.688329, 2.673593, 2.658847,
2.644090, 2.629326, 2.614553, 2.599773, 2.584985, 2.570193, 2.555394, 2.540591,
2.525782, 2.510970, 2.496155, 2.481338, 2.466517, 2.451697, 2.436876, 2.422054,
2.407232, 2.392412, 2.377594, 2.362779, 2.347965, 2.333155, 2.318350, 2.303550,
2.288753, 2.273964, 2.259181, 2.244405, 2.229635, 2.214875, 2.200124, 2.185382,
2.170649, 2.155927, 2.141216, 2.126518, 2.111830, 2.097156, 2.082495, 2.067848,
2.053215, 2.038597, 2.023995, 2.009409, 1.994839, 1.980287, 1.965753, 1.951236,
1.936738, 1.922260, 1.907802, 1.893364, 1.878945, 1.864550, 1.850176, 1.835825,
1.821495, 1.807190, 1.792909, 1.778653, 1.764420, 1.750214, 1.736033, 1.721879,
1.707752, 1.693652, 1.679580, 1.665537, 1.651523, 1.637537, 1.623580, 1.609655,
1.595760, 1.581897, 1.568065, 1.554266, 1.540499, 1.526765, 1.513062, 1.499395,
1.485762, 1.472164, 1.458601, 1.445074, 1.431583, 1.418128, 1.404708, 1.391327,
1.377984, 1.364679, 1.351412, 1.338184, 1.324995, 1.311846, 1.298735, 1.285666,
1.272638, 1.259651, 1.246706, 1.233802, 1.220941, 1.208122, 1.195344, 1.182611,
1.169923, 1.157278, 1.144677, 1.132121, 1.119610, 1.107144, 1.094723, 1.082348,
1.070021, 1.057740, 1.045505, 1.033318, 1.021179, 1.009087, 0.997041, 0.985046,
0.973100, 0.961202, 0.949354, 0.937555, 0.925806, 0.914107, 0.902456, 0.890858,
0.879311, 0.867814, 0.856369, 0.844976, 0.833635, 0.822345, 0.811106, 0.799921,
0.788789, 0.777710, 0.766684, 0.755712, 0.744793, 0.733928, 0.723115, 0.712358,
0.701655, 0.691007, 0.680413, 0.669875, 0.659391, 0.648963, 0.638589, 0.628272,
0.618010, 0.607805, 0.597656, 0.587562, 0.577526, 0.567545, 0.557620, 0.547753,
0.537943, 0.528190, 0.518494, 0.508855, 0.499274, 0.489750, 0.480283, 0.470874,
0.461523, 0.452230, 0.442995, 0.433819, 0.424700, 0.415639, 0.406636, 0.397692,
0.388806, 0.379979, 0.371211, 0.362501, 0.353850, 0.345258, 0.336723, 0.328248,
0.319832, 0.311475, 0.303177, 0.294937, 0.286757, 0.278636, 0.270572, 0.262569,
0.254624, 0.246739, 0.238912, 0.231145, 0.223437, 0.215788, 0.208196, 0.200665,
0.193193, 0.185779, 0.178425, 0.171129, 0.163892, 0.156715, 0.149594, 0.142534,
0.135532, 0.128589, 0.121705, 0.114879, 0.108112, 0.101403, 0.094751, 0.088159,
0.081625, 0.075149, 0.068731, 0.062371, 0.056069, 0.049825, 0.043638, 0.037509,
0.031438, 0.025424, 0.019468, 0.013569, 0.007727, 0.001942, -0.003787, -0.009458,
-0.015072, -0.020630, -0.026132, -0.031577, -0.036966, -0.042299, -0.047576, -0.052798,
-0.057963, -0.063073, -0.068128, -0.073127, -0.078071, -0.082961, -0.087796, -0.092576,
-0.097302, -0.101973, -0.106590, -0.111153, -0.115663, -0.120118, -0.124521, -0.128870,
-0.133166, -0.137409, -0.141599, -0.145737, -0.149822, -0.153856, -0.157837, -0.161767,
-0.165645, -0.169471, -0.173246, -0.176970, -0.180644, -0.184266, -0.187839, -0.191362,
-0.194834, -0.198256, -0.201629, -0.204953, -0.208227, -0.211453, -0.214630, -0.217759,
-0.220839, -0.223871, -0.226855, -0.229792, -0.232682, -0.235524, -0.238320, -0.241069,
-0.243771, -0.246428, -0.249038, -0.251603, -0.254123, -0.256597, -0.259026, -0.261411,
-0.263751, -0.266047, -0.268299, -0.270507, -0.272672, -0.274793, -0.276872, -0.278908,
-0.280901, -0.282853, -0.284762, -0.286630, -0.288456, -0.290241, -0.291985, -0.293689,
-0.295352, -0.296975, -0.298559, -0.300102, -0.301607, -0.303072, -0.304499, -0.305887,
-0.307236, -0.308548, -0.309822, -0.311059, -0.312258, -0.313421, -0.314547, -0.315637,
-0.316690, -0.317708, -0.318690, -0.319637, -0.320549, -0.321427, -0.322270, -0.323078,
-0.323853, -0.324594, -0.325302, -0.325977, -0.326619, -0.327228, -0.327806, -0.328351,
-0.328865, -0.329347, -0.329798, -0.330218, -0.330608, -0.330968, -0.331297, -0.331597,
-0.331867, -0.332108, -0.332320, -0.332504, -0.332659, -0.332786, -0.332885, -0.332957,
-0.333001, -0.333018, -0.333009, -0.332973, -0.332912, -0.332824, -0.332710, -0.332572,
-0.332408, -0.332219, -0.332006, -0.331769, -0.331508, -0.331222, -0.330914, -0.330582,
-0.330228, -0.329850, -0.329451, -0.329029, -0.328585, -0.328120, -0.327634, -0.327126,
-0.326598, -0.326049, -0.325480, -0.324891, -0.324282, -0.323654, -0.323006, -0.322340,
-0.321654, -0.320951, -0.320229, -0.319489, -0.318732, -0.317957, -0.317165, -0.316356,
-0.315530, -0.314688, -0.313830, -0.312955, -0.312066, -0.311160, -0.310239, -0.309304,
-0.308354, -0.307389, -0.306410, -0.305417, -0.304411, -0.303391, -0.302357, -0.301311,
-0.300251, -0.299179, -0.298095, -0.296999, -0.295891, -0.294771, -0.293639, -0.292497,
-0.291343, -0.290179, -0.289004, -0.287819, -0.286624, -0.285419, -0.284204, -0.282980,
-0.281747, -0.280504, -0.279253, -0.277993, -0.276725, -0.275449, -0.274164, -0.272872,
-0.271572, -0.270265, -0.268951, -0.267630, -0.266302, -0.264968, -0.263626, -0.262279,
-0.260927, -0.259568, -0.258203, -0.256834, -0.255459, -0.254079, -0.252693, -0.251304,
-0.249910, -0.248512, -0.247109, -0.245703, -0.244292, -0.242879, -0.241461, -0.240041,
-0.238617, -0.237191, -0.235762, -0.234330, -0.232896, -0.231459, -0.230020, -0.228580,
-0.227138, -0.225694, -0.224248, -0.222802, -0.221354, -0.219905, -0.218455, -0.217005,
-0.215554, -0.214102, -0.212651, -0.211199, -0.209747, -0.208295, -0.206844, -0.205393,
-0.203943, -0.202493, -0.201044, -0.199596, -0.198149, -0.196704, -0.195259, -0.193816,
-0.192375, -0.190936, -0.189498, -0.188062, -0.186628, -0.185197, -0.183767, -0.182340,
-0.180916, -0.179494, -0.178075, -0.176659, -0.175246, -0.173835, -0.172428, -0.171024,
-0.169624, -0.168227, -0.166833, -0.165443, -0.164057, -0.162675, -0.161296, -0.159922,
-0.158551, -0.157185, -0.155823, -0.154465, -0.153112, -0.151763, -0.150419, -0.149080,
-0.147745, -0.146415, -0.145090, -0.143770, -0.142455, -0.141145, -0.139840, -0.138540,
-0.137246, -0.135957, -0.134674, -0.133396, -0.132124, -0.130857, -0.129595, -0.128340,
-0.127090, -0.125847, -0.124609, -0.123377, -0.122151, -0.120931, -0.119717, -0.118509,
-0.117308, -0.116112, -0.114923, -0.113740, -0.112564, -0.111394, -0.110230, -0.109073,
-0.107923, -0.106779, -0.105641, -0.104510, -0.103386, -0.102268, -0.101157, -0.100053,
-0.098956, -0.097865, -0.096781, -0.095704, -0.094634, -0.093571, -0.092514, -0.091464,
-0.090422, -0.089386, -0.088357, -0.087336, -0.086321, -0.085313, -0.084312, -0.083319,
-0.082332, -0.081352, -0.080380, -0.079414, -0.078456, -0.077504, -0.076560, -0.075623,
-0.074693, -0.073770, -0.072854, -0.071945, -0.071043, -0.070148, -0.069261, -0.068380,
-0.067507, -0.066640, -0.065781, -0.064929, -0.064084, -0.063246, -0.062415, -0.061591,
-0.060774, -0.059964, -0.059161, -0.058365, -0.057576, -0.056794, -0.056018, -0.055250,
-0.054489, -0.053735, -0.052987, -0.052247, -0.051513, -0.050786, -0.050066, -0.049353,
-0.048646, -0.047946, -0.047253, -0.046567, -0.045888, -0.045215, -0.044548, -0.043888,
-0.043235, -0.042589, -0.041949, -0.041315, -0.040688, -0.040068, -0.039454, -0.038846,
-0.038245, -0.037650, -0.037061, -0.036479, -0.035903, -0.035333, -0.034769, -0.034211,
-0.033660, -0.033115, -0.032576, -0.032042, -0.031515, -0.030994, -0.030479, -0.029970,
-0.029466, -0.028968, -0.028477, -0.027991, -0.027510, -0.027036, -0.026567, -0.026103,
-0.025645, -0.025193, -0.024746, -0.024305, -0.023870, -0.023439, -0.023014, -0.022594,
-0.022180, -0.021771, -0.021367, -0.020968, -0.020575, -0.020186, -0.019803, -0.019424,
-0.019051, -0.018683, -0.018319, -0.017960, -0.017606, -0.017257, -0.016913, -0.016574,
-0.016239, -0.015908, -0.015583, -0.015262, -0.014945, -0.014633, -0.014326, -0.014022,
-0.013723, -0.013429, -0.013139, -0.012853, -0.012571, -0.012294, -0.012020, -0.011751,
-0.011486, -0.011224, -0.010967, -0.010714, -0.010465, -0.010219, -0.009977, -0.009740,
-0.009505, -0.009275, -0.009048, -0.008826, -0.008606, -0.008390, -0.008178, -0.007969,
-0.007764, -0.007562, -0.007364, -0.007169, -0.006977, -0.006789, -0.006604, -0.006422,
-0.006243, -0.006068, -0.005896, -0.005726, -0.005560, -0.005397, -0.005237, -0.005080,
-0.004926, -0.004774, -0.004626, -0.004480, -0.004338, -0.004198, -0.004061, -0.003926,
-0.003795, -0.003666, -0.003539, -0.003416, -0.003295, -0.003176, -0.003060, -0.002947,
-0.002836, -0.002727, -0.002621, -0.002517, -0.002416, -0.002317, -0.002221, -0.002126,
-0.002035, -0.001945, -0.001858, -0.001773, -0.001690, -0.001609, -0.001530, -0.001454,
-0.001380, -0.001308, -0.001238, -0.001170, -0.001104, -0.001040, -0.000978, -0.000919,
-0.000861, -0.000805, -0.000751, -0.000700, -0.000650, -0.000602, -0.000556, -0.000511,
-0.000469, -0.000429, -0.000390, -0.000354, -0.000319, -0.000286, -0.000255, -0.000226,
-0.000198, -0.000173, -0.000149, -0.000127, -0.000106, -0.000088, -0.000071, -0.000056,
-0.000043, -0.000032, -0.000022, -0.000014, -0.000008, -0.000004, -0.000001, 0.000000
};

// FFT buffer
float xyData[4096];

// Min and max of the leakage current signals
float minCH0 = 1000.0;
float minCH1 = 1000.0;
float minCH2 = 1000.0;
float minCH3 = 1000.0;
float minCH4 = 1000.0;
float minCH5 = 1000.0;

float maxCH0 = -1000.0;
float maxCH1 = -1000.0;
float maxCH2 = -1000.0;
float maxCH3 = -1000.0;
float maxCH4 = -1000.0;
float maxCH5 = -1000.0;

// RMS of the signals
float RMSVoltageCH0 = 0;
float RMSVoltageCH1 = 0;
float RMSVoltageCH2 = 0;
float RMSVoltageCH3 = 0;
float RMSVoltageCH4 = 0;
float RMSVoltageCH5 = 0;

// Phases of the signals
float phaseCH0 = 0;
float phaseCH1 = 0;
float phaseCH2 = 0;
float phaseCH3 = 0;
float phaseCH4 = 0;
float phaseCH5 = 0;

// SPI1 on PORTA
#define SS     GPIO_Pin_4  // Chip select of the MCP3903 ADC
#define SCK    GPIO_Pin_5  // Clock
#define MISO   GPIO_Pin_6  // Data out
#define MOSI   GPIO_Pin_7  // Data in

// ADC chipselect pin
#define MCP3903_CS_low	  GPIO_ResetBits(GPIOA, SS)
#define MCP3903_CS_high   GPIO_SetBits(GPIOA, SS)

// Zero cross signal input pin
#define WaitHiSIG   while ((GPIOB->IDR & GPIO_Pin_11) == 0)
#define WaitLoSIG   while ((GPIOB->IDR & GPIO_Pin_11) != 0)

// ADC dataready pin
#define WaitHiDRA   while ((GPIOA->IDR & GPIO_Pin_2) == 0)
#define WaitLoDRA   while ((GPIOA->IDR & GPIO_Pin_2) != 0)

// Bytes for ADC values (2 bytes each 16 bit value)
uint8_t MSB0, LSB0;
uint8_t MSB1, LSB1;
uint8_t MSB2, LSB2;
uint8_t MSB3, LSB3;
uint8_t MSB4, LSB4;
uint8_t MSB5, LSB5;

// Counter for the 4096 samples of the signal
uint16_t sample_counter;

// Phase shift counter in nanoseconds between zerocross and the actual
// ADC start to acquire data, based on /DRA pin of the ADC
volatile uint32_t CPUTicks;

uint8_t flag = 0;

// Functions definition for the SPI pheripheral and the ADC
void SPI_init(void);
uint8_t SPISend(uint8_t data);
void MCP3903_init(void);

// SRAM Hold line override
#define HOLD 1

// SRAM opcodes
#define RDSR  5
#define WRSR  1
#define READ  3
#define WRITE 2

#define RAMCLK1M   1

// SRAM modes
#define BYTE_MODE   (0x00 | HOLD)
#define PAGE_MODE   (0x80 | HOLD)
#define STREAM_MODE (0x40 | HOLD)

// SRAM chipselect pin
#define CS     GPIO_Pin_3

// SRAM chipselect pin
#define ENABLE_RAM	  GPIO_ResetBits(GPIOA, CS)
#define DISABLE_RAM   GPIO_SetBits(GPIOA, CS)

// Always do a &0xFF mask to assure we don't have sign problems
#define MSB(x)       ( x >> 8 ) & 0xFF
#define LSB(x)       (x & 0xFF)
#define COMB2WORD(_MSB,_LSB)   ( ( _MSB & 0xFF ) << 8 ) | ( _LSB & 0xFF );  // Bytes to word

#define TO_HEX(i) (i <= 9 ? '0' + i : 'A' - 10 + i) // DEC -> HEX
#define TO_DEC(i) (i <= '9'? i - '0': i - 'A' + 10) // HEX -> DEC
#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))  // Check if bit is set

// Volatile counter updated in Systick interrupt
volatile uint32_t TimingDelay;

void Delay(volatile uint32_t nTime)
{
    TimingDelay = nTime;

    while(TimingDelay != 0);
}

// Flag to to know when the Modbus data sending has complete
volatile uint8_t Modbus_End_Transmission_Flag;

// Modbus dataspace
u16 usRegHoldingBuf[40+1];  // 0..40 Holding registers
u8  usRegCoilBuf[64/8+1];  // 0..64  Coils

void writeCoil (uint8_t coil_index, uint8_t state) {
    uint8_t coil_offset=coil_index/8;
    if (state == 1)
        usRegCoilBuf[coil_offset] |= (1<<(coil_index%8));
    else usRegCoilBuf[coil_offset] &= ~(1<<(coil_index%8));
}

uint8_t getCoil (uint8_t coil_index) {
    uint8_t coil_byte=usRegCoilBuf[coil_index/8];
    if (coil_byte && (1<<(coil_index%8))) return 1;
    else return 0;
}

void writeHoldingRegister (uint8_t reg_index, uint16_t reg_val) {
    usRegHoldingBuf[reg_index] = reg_val;
}

uint16_t readHoldingRegister (uint8_t reg_index) {
    return usRegHoldingBuf[reg_index];
}

// DWT pheriperal registers
volatile uint32_t *DWT_CONTROL = (volatile uint32_t *)0xE0001000;
volatile uint32_t *DWT_CYCCNT  = (volatile uint32_t *)0xE0001004;
volatile uint32_t *SCB_DEMCR   = (volatile uint32_t *)0xE000EDFC;

void DWT_Enable (void) {
    // Enable the use of DWT
    *SCB_DEMCR = *SCB_DEMCR | 0x01000000;
    // Reset the counter
    *DWT_CYCCNT = 0;
    // Enable cycle counter
    *DWT_CONTROL = *DWT_CONTROL | 1;
}

#define PI        3.1415926535897932384626433832795
#define DEG2RAD   0.01745329251994329576923690768489
#define RAD2DEG   57.295779513082320876798154814105  // 180/PI
#define EPSILON   1e-8 // Small value for zero comparison

// Calculates the FFT phase at a given frequency index.
// Input: data is complex FFT Re[V(0)],Im[V(0)], Re[V(1)],Im[V(1)],...
// Input: nn is the number of points in the data and in the FFT,
//           nn must be a power of 2
// Input: k is frequency index 0 to nn/2-1
//        E.g., if nn = 4096, then k can be 0 to 2047
// Output: Phase at this frequency
// data is an array of 2*nn elements
// returns 0 if k >= nn/2
float myfftPhase (float data[], unsigned long nn, uint16_t k) {
    if (k >= nn / 2) {
        return 0.0; // out of range
    }

    // Extract the real and imaginary parts of the k-th element
    float real_part = data[2 * k];
    float imag_part = data[2 * k + 1];

    // Handle the case when both real and imaginary parts are zero (undefined phase)
    if (fabs(real_part) < EPSILON && fabs(imag_part) < EPSILON) {
        return 0.0; // phase is undefined
    }

    // Calculate the angle in radians using atan2
    float angle_rad = atan2(imag_part, real_part);

    // Convert the angle to degrees
    float angle_deg = angle_rad * RAD2DEG;

    angle_deg -= 222.884444;

    // Normalize the angle to be in the range [0, 360)
    if (angle_deg < 0) {
        angle_deg += 360.0;
    }

    // Adjust phase based on phase difference between bin 9 an 50 Hz
    // ( Value is not equal to theory, like always :))) )
    //angle_deg = fmodf((angle_deg - 222.884444), 360.0);

    // Normalize the angle to be in the range [0, 360)
    if (angle_deg < 0) {
        angle_deg += 360.0;
    }

    return angle_deg;
}

// Apply the Flat Top window to the signal
void apply_flattop_window(float *signal, const float *flattop_window, size_t num_points) {
    for (size_t n = 0; n < num_points; n++) {
        signal[n * 2] = signal[n * 2] * flattop_window[n]; // Apply the window to the real part
    }
}

// Load to xyData buffer the selected signal from the SRAM memory
void load_Channel_To_FFTbuffer (uint8_t channel) {
	uint16_t i;

	// Start reading from adress zero
    ENABLE_RAM;
    SPISend(READ);
    SPISend(0x00);  // MSB
    SPISend(0x00);  // LSB

	i = 0;
    while (i < 4096) {
    	// Read all 6 channels at once from SRAM
		MSB0 = SPISend(0xFF); LSB0 = SPISend(0xFF);
		MSB1 = SPISend(0xFF); LSB1 = SPISend(0xFF);
		MSB2 = SPISend(0xFF); LSB2 = SPISend(0xFF);
		MSB3 = SPISend(0xFF); LSB3 = SPISend(0xFF);
		MSB4 = SPISend(0xFF); LSB4 = SPISend(0xFF);
		MSB5 = SPISend(0xFF); LSB5 = SPISend(0xFF);

		// We use MSB0 and LSB0 for every channel to conserve memory
		switch (channel) {
    	    //case 0:
	        //    MSB0 = MSB0;  :)
	        //    LSB0 = LSB0;
	        //    break;
		    case 1:
		        MSB0 = MSB1;
		        LSB0 = LSB1;
		        break;
		    case 2:
		        MSB0 = MSB2;
		        LSB0 = LSB2;
		        break;
		    case 3:
		        MSB0 = MSB3;
		        LSB0 = LSB3;
		        break;
		    case 4:
		        MSB0 = MSB4;
		        LSB0 = LSB4;
		        break;
		    case 5:
		        MSB0 = MSB5;
		        LSB0 = LSB5;
		        break;
		    default:
		        // Optional: Handle invalid channel case if needed
		        break;
		}

		// Data is from 2 in 2, Re,Im, Re,Im,...
		// Convert 16 bit ADC values to actual voltage
		xyData[i] = ((float)((int16_t)((MSB0 << 8) | LSB0)) / 32767.0 / 3.0) * 2.39;  // ADC Vref = 2.39V
		// The imaginary side is zero when we load the real signal
		xyData[i + 1] = 0;

		// Each time we load a channel to FFT buffer, we also find the MIN and MAX
		// and update the global variables
		switch (channel) {
		    case 0:
		        if (xyData[i] > maxCH0) maxCH0 = xyData[i];
		        if (xyData[i] < minCH0) minCH0 = xyData[i];
		        break;
		    case 1:
		        if (xyData[i] > maxCH1) maxCH1 = xyData[i];
		        if (xyData[i] < minCH1) minCH1 = xyData[i];
		        break;
		    case 2:
		        if (xyData[i] > maxCH2) maxCH2 = xyData[i];
		        if (xyData[i] < minCH2) minCH2 = xyData[i];
		        break;
		    case 3:
		        if (xyData[i] > maxCH3) maxCH3 = xyData[i];
		        if (xyData[i] < minCH3) minCH3 = xyData[i];
		        break;
		    case 4:
		        if (xyData[i] > maxCH4) maxCH4 = xyData[i];
		        if (xyData[i] < minCH4) minCH4 = xyData[i];
		        break;
		    case 5:
		        if (xyData[i] > maxCH5) maxCH5 = xyData[i];
		        if (xyData[i] < minCH5) minCH5 = xyData[i];
		        break;
		    default:
		        // Handle unexpected channel values if necessary
		        break;
		}

        i += 2;
    }
    DISABLE_RAM;
}

// Helper macro to swap two float values
#define SWAP(a, b) { float temp = (a); (a) = (b); (b) = temp; }

// FFT optimized for a signal array only with real side values, no imaginary
// Input: nn is the number of points in the data and in the FFT (must be a power of 2).
// Input: data is an array of nn real elements (no imaginary part initially, from ADC)
//        Re(0),0,Re(1),0,Re(2),...Re(nn-1),0
// Output: data will be transformed to contain complex FFT coefficients where the real
//         and imaginary parts are interleaved in the same array (Re, Im, Re, Im...).
void real_fft (float data[], unsigned long nn) {
    unsigned long n, mmax, m, j, istep, i;
    double wtemp, wr, wpr, wpi, wi, theta;
    double tempr, tempi;

    // `nn` is the number of real samples. In the complex FFT,
    // `n` will be twice `nn` because each complex number has two parts (Re and Im).
    n = nn << 1;  // n = 2 * nn, for real + imaginary storage (even though input is real, output will be complex)

    // ---- Bit-reversal Reordering ----
    // The FFT requires the input to be in bit-reversed order to optimize
    // in-place computation. Here we rearrange the data in such order.
    j = 1;
    for (i = 1; i < n; i += 2) {
        if (j > i) {  // Swap only if j > i to avoid swapping elements back
            SWAP(data[j-1], data[i-1]);  // Swap the real part
            SWAP(data[j], data[i]);      // Swap the imaginary part (initially 0)
        }

        // Bit-reversal logic (this shifts the bits around in a specific way
        // to reorder the data).
        m = n >> 1;
        while (m >= 2 && j > m) {
            j -= m;
            m >>= 1;
        }
        j += m;
    }

    // ---- Danielson-Lanczos Recursion ----
    // This is the heart of the FFT algorithm, where the computation is performed
    // in a recursive, divide-and-conquer manner.
    mmax = 2;  // mmax starts at 2 (which means we first handle 2-element blocks)
    while (n > mmax) {
        istep = mmax << 1;  // Step size for each FFT recursion level (block size)

        // Calculate the angle (theta) for the trigonometric recurrence relation
        // that is used to compute the FFT (twiddle factors).
        theta = -2.0 * PI / mmax;
        wtemp = sin(0.5 * theta);
        wpr = -2.0 * wtemp * wtemp;  // Real part of twiddle factor
        wpi = sin(theta);            // Imaginary part of twiddle factor
        wr = 1.0;                    // Starting value for twiddle real part (cos(0) = 1)
        wi = 0.0;                    // Starting value for twiddle imaginary part (sin(0) = 0)

        // For each recursion level, we loop through the data in chunks
        // of size `mmax`, computing the FFT step for each pair of elements.
        for (m = 1; m < mmax; m += 2) {
            for (i = m; i <= n; i += istep) {
                // The FFT is performed in pairs of elements. We compute the
                // real and imaginary parts of these elements and apply the twiddle factors.
                j = i + mmax;  // This is the other element in the pair

                // Calculate the real and imaginary components of the twiddle factor for this step
                tempr = wr * data[j-1] - wi * data[j];
                tempi = wr * data[j] + wi * data[j-1];

                // Update the real and imaginary parts with the calculated values
                data[j-1] = data[i-1] - tempr;
                data[j]   = data[i]   - tempi;
                data[i-1] = data[i-1] + tempr;
                data[i]   = data[i]   + tempi;
            }

            // Update the twiddle factors for the next iteration. This is done
            // using the recurrence relation for trigonometric functions.
            wtemp = wr;
            wr = wr * wpr - wi * wpi + wr;
            wi = wi * wpr + wtemp * wpi + wi;
        }

        // Double the block size for the next level of recursion.
        mmax = istep;
    }
}

// Adjust the phase to be an integer with `2 decimals` ( * 100)
uint16_t adjust_phase(float phase, float phase_difference) {
	// If phase difference it to big something is broken
	if (phase_difference >= 359.0)  // THE DWT TICKS COUNTER HAS GONE WHILD ON US !!! :)
		return 0;

	// Subtract the small delay from the moment we had zero-cross impulse
	// till the moment the ADC had first data ready (/DRA high)
    float adjusted_phase = phase - phase_difference;

    // Ensure the result is in the range [0, 360)
    if (adjusted_phase < 0) {
        adjusted_phase += 360.0;
    }

    // Scale by 100 and return as an integer. We keep two decimals of precision
    return (uint16_t)(adjusted_phase * 100.0);
}

// Adjust the voltage so that we have current only in 0..100 mA
uint16_t adjust_voltage (float voltage) {
	uint16_t voltage_value = 0;

    // Prevent negative values
	if (voltage < 0)
    	return 0;

    // Scale by 10000 and convert to integer
	// The ADC `sees` voltage up to 0.6V without degraded precision
	voltage_value = (uint16_t)(voltage * 10000.0);

	// Top voltage at 100 mA (0.1 A * 5.6 OHM = 0.56 V * 10000.0 = 5600)
	if (voltage_value > 5600)
		return 5600;

	return voltage_value;
}

int main (void) {
    GPIO_InitTypeDef GPIO_InitStructure;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    TIM_OCInitTypeDef TIM_OCInitStructure;

    uint8_t step_counter;  // State machine counter

    // --->>> Vectors position was set in system_stm32f10x.c, line 128
    // Set the Vector Table base adress at 0x8004000
    // NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x4000);

    /************************************************************
    *   Enable Systick interrupt at 1 ms
    *************************************************************/
    if (SysTick_Config(72000)) {  // 1 ms interrupt 72 MHz / 72000 = 1000
        // Capture error
        while (1);
    }

    /************************************************************
    *   Enable the use of internal DWT for counting
    *************************************************************/
    DWT_Enable();

    /************************************************************
    *   Init B6,B7,B8,B9,B12,B13,B14,B15 relays
    *************************************************************/
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15 | GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_12 | GPIO_Pin_9 | GPIO_Pin_8 | GPIO_Pin_7 | GPIO_Pin_6;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    /************************************************************
    *   All relays OFF
    *************************************************************/
    GPIOB->BSRR = GPIO_Pin_15 |GPIO_Pin_14 |GPIO_Pin_13 | GPIO_Pin_12 |GPIO_Pin_9 |GPIO_Pin_8 | GPIO_Pin_7 | GPIO_Pin_6;

    /************************************************************
    *   Init led PC13 (BluePill LED)
    *************************************************************/
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC , ENABLE);
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init(GPIOC, &GPIO_InitStructure);

    /************************************************************
    *   Init PB0 & PB1 side switching (A,B,C / a, b, c)
    *************************************************************/
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    // Set pins to LOW
    GPIOB->BRR = GPIO_Pin_1 |GPIO_Pin_0;

    /************************************************************
    *   Init PA2 as input floating to get /DRA channel
    *************************************************************/
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /************************************************************
    *   Start TIM2_CH2 on pin PA1 at 3 MHz, 50 % duty
    *   as clock for MCP3903 ADC
    *************************************************************/
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    GPIO_StructInit(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init( GPIOA, &GPIO_InitStructure );

    /************************************************************
    *   TIM2 clock enable
    *************************************************************/
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 , ENABLE);
    TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    TIM_TimeBaseStructure.TIM_Prescaler = 12 - 1;  // 72 MHz / 12 = 6 MHz
    TIM_TimeBaseStructure.TIM_Period = 2 - 1;  // 6 MHz / 2 = 3 MHz  / 256 = 11718.75
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

    TIM_OCStructInit(&TIM_OCInitStructure);
    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCInitStructure.TIM_Pulse = 0;
    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    TIM_OC2Init(TIM2, &TIM_OCInitStructure);  // Channel 2 configuration = PA1

    TIM_ARRPreloadConfig(TIM2, ENABLE);
    TIM_CtrlPWMOutputs(TIM2, ENABLE);
    TIM_Cmd(TIM2, ENABLE);
    TIM2->CCR2 = 1;

    /************************************************************
    *   Init PB11 as input floating to get zero-cross impulse
    *************************************************************/
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
    GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    /************************************************************
    *   Full SWJ Disabled (JTAG-DP + SW-DP)
    *************************************************************/
    //GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);

    /************************************************************
    *   Init SPI peripheral
    *************************************************************/
    SPI_init();
    Delay(500);

    /************************************************************
    *   Init ADC
    *************************************************************/
    MCP3903_init();
    Delay(500);

    /************************************************************
    *   Init RAM in byte mode
    *************************************************************/
    ENABLE_RAM;
    SPISend(WRSR);
    SPISend(STREAM_MODE);
    DISABLE_RAM;
    Delay(500);

    /*************************************************************
    *   Init Modbus
    *************************************************************/
    // Initialize protocol stack in RTU mode for a slave with address 8
	// MB_RTU, Device ID: 1, USART portL: 1
    // (is configured in portserial.h, Baud rate: 19200, Parity: NONE)
    eMBInit(MB_RTU, 8, 1, 19200, MB_PAR_NONE);
	// Enable the Modbus Protocol Stack.
    eMBEnable();

	step_counter = 0;

    TimingDelay = 0;

	while (1) {
		Modbus_End_Transmission_Flag = 0;
		eMBPoll();

		// Everything happends right after modbus ended the transmission of data
		if (Modbus_End_Transmission_Flag == 1) {
			// Update relays state on each modbus interogation
			// B12  -  K1
			// B9   -  K2
			// B13  -  K3
			// B8   -  K4
			// B14  -  K5
			// B7   -  K6 - WDH
			// B15  -  K7 - WDS
			// B6   -  K8 - WDA
			// B0   -  switch high side (A,B,C)
			// B1   -  switch low side (a,b,c)

			// Starts from 31 so in RMMS it will be from 30 holding register
			if (readHoldingRegister(31) == 0) GPIOB->BSRR = GPIO_Pin_12;
			else  GPIOB->BRR = GPIO_Pin_12;
			if (readHoldingRegister(32) == 0) GPIOB->BSRR = GPIO_Pin_9;
			else  GPIOB->BRR = GPIO_Pin_9;
			if (readHoldingRegister(33) == 0) GPIOB->BSRR = GPIO_Pin_13;
			else  GPIOB->BRR = GPIO_Pin_13;
			if (readHoldingRegister(34) == 0) GPIOB->BSRR = GPIO_Pin_8;
			else  GPIOB->BRR = GPIO_Pin_8;
			if (readHoldingRegister(35) == 0) GPIOB->BSRR = GPIO_Pin_14;
			else  GPIOB->BRR = GPIO_Pin_14;
			if (readHoldingRegister(36) == 0) GPIOB->BSRR = GPIO_Pin_7;
			else  GPIOB->BRR = GPIO_Pin_7;
			if (readHoldingRegister(37) == 0) GPIOB->BSRR = GPIO_Pin_15;
			else  GPIOB->BRR = GPIO_Pin_15;
			if (readHoldingRegister(38) == 0) GPIOB->BSRR = GPIO_Pin_6;
			else  GPIOB->BRR = GPIO_Pin_6;

			// Switch to HIGH side (B0)
			if (readHoldingRegister(39) == 1) {
				// Reset command register to prevent repeated execution
				writeHoldingRegister(39, 0);
				GPIOB->BSRR = GPIO_Pin_0;
				// Small delay to ensure latching relays change state
				Delay(100);
				GPIOB->BRR = GPIO_Pin_0;
			}

			// Switch to LOW side (B1)
			if (readHoldingRegister(40) == 1) {
				// Reset command register to prevent repeated execution
				writeHoldingRegister(40, 0);
				GPIOB->BSRR = GPIO_Pin_1;
				// Small delay to ensure latching relays change state
				Delay(100);
				GPIOB->BRR = GPIO_Pin_1;
			}

			// STEP 0 ==== load data to SRAM
			if (step_counter == 0) {
				// Toggle LED
				GPIOC->ODR ^= GPIO_Pin_13;

				// Wait for zero cross trigger signal transition
				WaitLoSIG;
			    WaitHiSIG;

				flag = 0;
				sample_counter = 0;

				// There is a small delay between the zero-cross impulse and the effective start of the
				// acquisition, and because of the MCP3903 clock running slower than the Cortex core,
				// we can measure and subtract this from phase to enhance accuracy :).
				// We count this interval using DWT, in ticks (1tick = 13.8888888... ns)
                // To convert from DWT ticks counter to seconds:
				//     Time_in_seconds = DWTticks / 72000000
				// The angle covered per second at 50 Hz is:
				//     Degrees_per_second = 360 degrees per cycle x 50 cycles/second = 18000 degrees/second
                // So to convert DWT ticks to angle:
				//     angle = (DWTticks / 72000000) * 18000 degrees/second
				//           = DWTticks * 0.00025
		// !!! START CRITICAL CODE !!!
				*DWT_CYCCNT = 0;  // DWT resolution is 13.8888888... ns per clock tick
				while (sample_counter < 2048) {
					// Wait for ADC data ready pin low state
					WaitLoDRA;
					if (flag == 0) {  // Only once in the while :)
						CPUTicks = *DWT_CYCCNT;  // Save how many ticks
		// !!! END CRITICAL CODE !!!
						flag = 1;
					}
					// Wait for ADC data ready pin high state
					WaitHiDRA;
                    // Read data from ADC for all 6 channels
					MCP3903_CS_low;
					MSB0 = SPISend(0x41);
					MSB0 = SPISend(0x00); LSB0 = SPISend(0x00);
					MSB1 = SPISend(0x00); LSB1 = SPISend(0x00);
					MSB2 = SPISend(0x00); LSB2 = SPISend(0x00);
					MSB3 = SPISend(0x00); LSB3 = SPISend(0x00);
					MSB4 = SPISend(0x00); LSB4 = SPISend(0x00);
					MSB5 = SPISend(0x00); LSB5 = SPISend(0x00);
					MCP3903_CS_high;
                    // Store all 6 channels at once to SRAM
					ENABLE_RAM;
					SPISend(WRITE);
					// We jump 12 by 12 bytes (6 x 16 bit values, for each MSB and LSB)
					SPISend((char)((sample_counter * 12) >> 8));  // MSB  ((char)(address >> 8))
					SPISend((char)(sample_counter * 12));  // LSB  ((char)address)
					SPISend(MSB0); SPISend(LSB0);
					SPISend(MSB1); SPISend(LSB1);
					SPISend(MSB2); SPISend(LSB2);
					SPISend(MSB3); SPISend(LSB3);
					SPISend(MSB4); SPISend(LSB4);
					SPISend(MSB5); SPISend(LSB5);
					DISABLE_RAM;

					sample_counter++;
				}
			}

            // MAX, MIN and PHASE for CH0, CH1, CH2
			if (step_counter == 1)
			{
				// Compute MAX, MIN and fundamental phase for channel CH0
				minCH0 = 1000.0;
				maxCH0 = -1000.0;
				// Load data to FFT buffer and get MAX and MIN for this channel
				load_Channel_To_FFTbuffer(0);
				RMSVoltageCH0 = (maxCH0 - minCH0) * 0.353;
			    if (RMSVoltageCH0 > 0.015) {  // Equivalent to 2.678 mA on 5.6 ohm resistor (minimum value accepted)
			    	// Apply Flat Top window to the signal
			    	apply_flattop_window(xyData, flattop_window, 2048);
			        // Compute FFT
			        real_fft(xyData, 2048);
			        // Compute fundamental phase
			        phaseCH0 = myfftPhase(xyData, 2048, 9);
			    } else {
			    	phaseCH0 = 0.0;
				}

				// Compute MAX, MIN and fundamental phase for channel CH1
				minCH1 = 1000.0;
				maxCH1 = -1000.0;
				// Load data to FFT buffer and get MAX and MIN for this channel
				load_Channel_To_FFTbuffer(1);
				RMSVoltageCH1 = (maxCH1 - minCH1) * 0.353;
			    if (RMSVoltageCH1 > 0.015) {  // Equivalent to 2.678 mA on 5.6 ohm resistor (minimum value accepted)
			    	// Apply Flat Top window to the signal
			    	apply_flattop_window(xyData, flattop_window, 2048);
					// Compute FFT
					real_fft(xyData, 2048);
					// Compute fundamental phase
					phaseCH1 = myfftPhase(xyData, 2048, 9);
				} else {
					phaseCH1 = 0.0;
				}

				// Compute MAX, MIN and fundamental phase for channel CH2
				minCH2 = 1000.0;
				maxCH2 = -1000.0;
				// Load data to FFT buffer and get MAX and MIN for this channel
				load_Channel_To_FFTbuffer(2);
				RMSVoltageCH2 = (maxCH2 - minCH2) * 0.353;
			    if (RMSVoltageCH2 > 0.015) {  // Equivalent to 2.678 mA on 5.6 ohm resistor (minimum value accepted)
			    	// Apply Flat Top window to the signal
			    	apply_flattop_window(xyData, flattop_window, 2048);
			        // Compute FFT
			        real_fft(xyData, 2048);
			        // Compute fundamental phase
			        phaseCH2 = myfftPhase(xyData, 2048, 9);
			    } else {
			    	phaseCH2 = 0.0;
				}
			}

            // MAX, MIN and PHASE for CH3, CH4, CH5
			if (step_counter == 2)
			{
				// Compute MAX, MIN and fundamental phase for channel CH3
				minCH3 = 1000.0;
				maxCH3 = -1000.0;
				// Load data to FFT buffer and get MAX and MIN for this channel
				load_Channel_To_FFTbuffer(3);
				RMSVoltageCH3 = (maxCH3 - minCH3) * 0.353;
			    if (RMSVoltageCH3 > 0.015) {  // Equivalent to 2.678 mA on 5.6 ohm resistor (minimum value accepted)
			    	// Apply Flat Top window to the signal
			    	apply_flattop_window(xyData, flattop_window, 2048);
			        // Compute FFT
			        real_fft(xyData, 2048);
			        // Compute fundamental phase
			        phaseCH3 = myfftPhase(xyData, 2048, 9);
			    } else {
			    	phaseCH3 = 0.0;
				}

				// Compute MAX, MIN and fundamental phase for channel CH4
				minCH4 = 1000.0;
				maxCH4 = -1000.0;
				// Load data to FFT buffer and get MAX and MIN for this channel
				load_Channel_To_FFTbuffer(4);
				RMSVoltageCH4 = (maxCH4 - minCH4) * 0.353;
			    if (RMSVoltageCH4 > 0.015) {  // Equivalent to 2.678 mA on 5.6 ohm resistor (minimum value accepted)
			    	// Apply Flat Top window to the signal
			    	apply_flattop_window(xyData, flattop_window, 2048);
					// Compute FFT
					real_fft(xyData, 2048);
					// Compute fundamental phase
					phaseCH4 = myfftPhase(xyData, 2048, 9);
				} else {
					phaseCH4 = 0.0;
				}

				// Compute MAX, MIN and fundamental phase for channel CH5
				minCH5 = 1000.0;
				maxCH5 = -1000.0;
				// Load data to FFT buffer and get MAX and MIN for this channel
				load_Channel_To_FFTbuffer(5);
				RMSVoltageCH5 = (maxCH5 - minCH5) * 0.353;
			    if (RMSVoltageCH5 > 0.015) {  // Equivalent to 2.678 mA on 5.6 ohm resistor (minimum value accepted)
			    	// Apply Flat Top window to the signal
			    	apply_flattop_window(xyData, flattop_window, 2048);
			        // Compute FFT
			        real_fft(xyData, 2048);
			        // Compute fundamental phase
			        phaseCH5 = myfftPhase(xyData, 2048, 9);
			    } else {
			    	phaseCH5 = 0.0;
				}

				// Save RMS voltage to Modbus server
				writeHoldingRegister(1, adjust_voltage(RMSVoltageCH0));
				writeHoldingRegister(2, adjust_voltage(RMSVoltageCH1));
				writeHoldingRegister(3, adjust_voltage(RMSVoltageCH2));
				writeHoldingRegister(4, adjust_voltage(RMSVoltageCH3));
				writeHoldingRegister(5, adjust_voltage(RMSVoltageCH4));
				writeHoldingRegister(6, adjust_voltage(RMSVoltageCH5));

				// Convert DWT ticks to angle
				float phase_difference = (float)(CPUTicks * 0.00025);

				// Write phase to modbus server
				writeHoldingRegister( 7, adjust_phase(phaseCH0, phase_difference));
				writeHoldingRegister( 8, adjust_phase(phaseCH1, phase_difference));
				writeHoldingRegister( 9, adjust_phase(phaseCH2, phase_difference));
				writeHoldingRegister(10, adjust_phase(phaseCH3, phase_difference));
				writeHoldingRegister(11, adjust_phase(phaseCH4, phase_difference));
				writeHoldingRegister(12, adjust_phase(phaseCH5, phase_difference));
			}

			step_counter++;
			if (step_counter >= 3) {   // Reset state machine
				step_counter = 0;
				//GPIOC->ODR ^= GPIO_Pin_13;
			}

		}
    }
}

void SPI_init(void) {
    SPI_InitTypeDef  SPI_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    GPIO_InitStructure.GPIO_Pin = SCK | MISO | MOSI;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = SS | CS;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /*
    Configure SPI1 in Mode 0:
        CPOL = 0 --> clock is low when idle
        CPHA = 0 --> data is sampled at the first edge

    SPI Master mode,
    8 bits of data,
    clock prescalar is 256,
    MSB is transmitted first.
    */

    MCP3903_CS_high;
    DISABLE_RAM;

    /* SPI1 Config */
    SPI_StructInit(&SPI_InitStructure);
    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
    SPI_Init(SPI1, &SPI_InitStructure);
    /* Enable SPI1 */
    SPI_Cmd(SPI1, ENABLE);
}

uint8_t SPISend(uint8_t data) {
    /******************************************************
    *   ====> SPI interface works in mode CPOL = 0 and CPHA = 0
    *   Set the data register to the byte to be transmitted
    *   Wait for data transmission on MOSI to complete
    *   Wait for data reception on MISO to complete
    *   Wait until SPI is no longer busy
    *   Transfer the received data from the data register
    *******************************************************/
    // Setting the Data Register (DR) transmits the byte of data on MOSI.
    SPI1->DR = data;
    // Wait until the data has been transmitted.
    while (!(SPI1->SR & SPI_I2S_FLAG_TXE));

    // Wait for any data on MISO pin to be received.
    while (!(SPI1->SR & SPI_I2S_FLAG_RXNE));

    // All data transmitted/received but SPI may be busy so wait until done.
    while (SPI1->SR & SPI_I2S_FLAG_BSY);

    // Return the data received on MISO pin.
    return(SPI1->DR);
}

void MCP3903_init(void) {
  	MCP3903_CS_low;
    SPISend(0x54);
    SPISend(0xFC);
    SPISend(0x0F);
    SPISend(0xD1);
  	MCP3903_CS_high;

  	MCP3903_CS_low;
    SPISend(0x50);
    SPISend(0x00);
    SPISend(0x00);
    SPISend(0x00);
	MCP3903_CS_high;

	MCP3903_CS_low;
    SPISend(0x4E);
    SPISend(0x00);
    SPISend(0x00);
    SPISend(0x00);
	MCP3903_CS_high;

	MCP3903_CS_low;
    SPISend(0x52);
    SPISend(0x80);
    SPISend(0x70);
    SPISend(0x00);
	MCP3903_CS_high;

	MCP3903_CS_low;
    SPISend(0x54);
    SPISend(0x00);
    SPISend(0x0F);
    SPISend(0xD1);
	MCP3903_CS_high;

/*
    SPI interface works in mode CPOL = 0 and CPHA = 0

	INITIALIZATION RUTINE FOR MCP3903
	=================================
	CS_HIGH
	CS_LOW
		0x54, 0xFC, 0x0F, 0xD1   // 0x0A CONFIG
	CS_HIGH
	CS_LOW
		0x50, 0x00, 0x00, 0x00   // 0x08 GAIN
	CS_HIGH
	CS_LOW
		0x4E, 0x00, 0x00, 0x00   // 0x07 PHASE
	CS_HIGH
	CS_LOW
		0x52, 0x80, 0x70, 0x00   // 0x09 STATUS/COM
	CS_HIGH
	CS_LOW
		0x54, 0x00, 0x0F, 0xD1   // 0x0A CONFIG
	CS_HIGH
	#############################################
	CONFIG      111111000000111111010001
	GAIN        0
	PHASE       0
	STATUS/COM  100000000111000000000000
	CONFIG      000000000000111111010001
	#############################################
	CONFIG
	===============
	RESET_CH5     1
	RESET_CH4     1
	RESET_CH3     1
	RESET_CH2     1
	RESET_CH1     1
	RESET_CH0     1
	---------------
	SHUTDOWN_CH5  0
	SHUTDOWN_CH4  0
	SHUTDOWN_CH3  0
	SHUTDOWN_CH2  0
	SHUTDOWN_CH1  0
	SHUTDOWN_CH0  0
	---------------
	DITHER_CH5    1
	DITHER_CH4    1
	DITHER_CH3    1
	DITHER_CH2    1
	DITHER_CH1    1
	DITHER_CH0    1
	---------------
	OSR1,         0
	OSR0          1
	---------------
	PRESCALE1,    0
	PRESCALE0     0
	---------------
	EXTVREF       0
	---------------
	EXTCLK        1
	#############################################
	STATUS/COM
	===============
	READ1         1
	READ0         0
	---------------
	WMODE         0
	---------------
	WIDTH_CH5     0
	WIDTH_CH4     0
	WIDTH_CH3     0
	WIDTH_CH2     0
	WIDTH_CH1     0
	WIDTH_CH0     0
	---------------
	DR_LTY        1
	---------------
	DR_HIZ        1
	---------------
	DR_LINK       1
	---------------
	DRC_MODE1     0
	DRC_MODE0     0
	---------------
	DRB_MODE1     0
	DRB_MODE0     0
	---------------
	DRA_MODE1     0
	DRA_MODE0     0
	---------------
	DRSTATUS_CH5  0
	DRSTATUS_CH4  0
	DRSTATUS_CH3  0
	DRSTATUS_CH2  0
	DRSTATUS_CH1  0
	DRSTATUS_CH0  0
 */
}

/*// Original FFT function (now we use one optimized only for real side computation)
// Input: nn is the number of points in the data and in the FFT,
//           nn must be a power of 2
// Input: data is sampled voltage v(0),0,v(1),0,v(2),...v(nn-1),0 versus time
// Output: data is complex FFT Re[V(0)],Im[V(0)], Re[V(1)],Im[V(1)],...
// data is an array of 2*nn elements
void fft (float data[], unsigned long nn) {
    unsigned long n,mmax,m,j,istep,i;
    double wtemp,wr,wpr,wpi,wi,theta;
    double tempr,tempi;

    n = nn << 1;  // n is the size of data array (2*nn)
	j = 1;
	for (i=1; i<n; i+=2) {
		if (j > i) {   // bit reversal section
			SWAP(data[j-1], data[i-1]);
			SWAP(data[j], data[i]);
		}

		m = n >> 1;

		while ((m >= 2)&&(j > m)) {
			j = j - m;
			m = m >> 1;
		}

		j = j + m;
	}

	// Danielson-Lanczos section
	mmax = 2;
	while (n > mmax) {    // executed log2(nn) times
		istep = mmax << 1;
		theta = -6.283185307179586476925286766559 / mmax;
		// the above line should be + for inverse FFT
		wtemp = sin(0.5 * theta);
		wpr = -2.0 * wtemp * wtemp;  // real part
		wpi = sin(theta);        // imaginary part
		wr = 1.0;
		wi = 0.0;

		for (m=1; m<mmax; m+=2) {
			for (i=m; i<=n; i=i+istep) {
				j = i + mmax;
				tempr     = wr * data[j-1] - wi * data[j]; // Danielson-Lanczos formula
				tempi     = wr * data[j] + wi * data[j-1];
				data[j-1] = data[i-1] - tempr;
				data[j]   = data[i] - tempi;
				data[i-1] = data[i-1] + tempr;
				data[i]   = data[i] + tempi;
			}

			wtemp = wr;
			wr = wr * wpr - wi * wpi + wr;
			wi = wi * wpr + wtemp * wpi + wi;
		}

		mmax = istep;
	}
}
 */

/*
// compute current using the rms of the voltage from 5.6ohm resistor
// return value in mA with one decimals after quota
uint16_t compute_current (float voltage) {
	uint16_t current = (uint16_t)((voltage / 5.6) * 10000.0);

	// Leakage current maximum at 100 mA (*10)
	if (current < 0) current = 0;
	if (current > 1000) current = 1000;

	return (current);
}
 */

/*// THIS WAS MY OLD ATAN2 IMPLEMENTATION
float myatan2(float y, float x)
{
    float v = 0;

    if (x > 0) v = atan(y / x);                    // First Quadrant
    if ((y >= 0) && (x < 0)) v = PI + atan(y / x); // Second Quadrant
    if ((y < 0) && (x < 0)) v = -PI + atan(y / x); // Third Quadrant
    if ((y > 0) && (x == 0)) v = PI / 2;           // Positive Y-axis
    if ((y < 0) && (x == 0)) v = -PI / 2;          // Negative Y-axis
    if (v < 0) v = v + 2 * PI;                     // Normalize to [0, 2*PI]

    return v;

    // First Quadrant: If x is positive, the angle is directly calculated using atan(y/x)
    // Second Quadrant: If x is negative and y is non-negative, the angle is adjusted by adding PI (180 degrees)
    // Third Quadrant: If both x and y are negative, the angle is adjusted by subtracting PI
    // Positive Y-axis: If x is zero and y is positive, the angle is PI/2 (90 degrees)
    // Negative Y-axis: If x is zero and y is negative, the angle is -PI/2 (or equivalently 3PI/2)
    // Normalization: Finally, if the calculated angle v is negative, it is normalized by adding 2PI to bring it within the range [0,2PI]
}
*/

/*
#define TO_HEX(i) (i <= 9 ? '0' + i : 'A' - 10 + i)

void SERIAL_Print_32bit_Hex(USART_TypeDef* USARTx, uint32_t x)
{
    char res[11];

    if (x <= 0xFFFFFFFF)
    {
        res[0] = '0';
        res[1] = 'x';
        res[2] = TO_HEX(((x & 0xF0000000) >> 28));
        res[3] = TO_HEX(((x & 0x0F000000) >> 24));
        res[4] = TO_HEX(((x & 0x00F00000) >> 20));
        res[5] = TO_HEX(((x & 0x000F0000) >> 16));
        res[6] = TO_HEX(((x & 0x0000F000) >> 12));
        res[7] = TO_HEX(((x & 0x00000F00) >> 8));
        res[8] = TO_HEX(((x & 0x000000F0) >> 4));
        res[9] = TO_HEX(( x & 0x0000000F));
        res[10] = '\0';
    }
    SERIAL_Print(USARTx, res);
}
 */

// This macros defines an alpha value between 0 and 1
// Alpha values close to zero represent heavy averaging while an alpha value of one has no averaging.
// An exponential moving average is expressed as the following equation:
//       avg[n] = (in * alpha) + avg[n-1]*(1-alpha).
// Implementing this equation using floating point math is straightforward but using
// fixed point variables is a little tricky.
// The code snippet here use 32-bit signed integers for the average and input values.
// Intermediate values  need to use 64-bit math to avoid overflow errors.
/*
#define DSP_EMA_I32_ALPHA(x) ( (uint16_t)(x * 65535) )

int32_t dsp_ema_i32(int32_t in, int32_t average, uint16_t alpha){
  int64_t tmp0; //calcs must be done in 64-bit math to avoid overflow
  tmp0 = (int64_t)in * (alpha) + (int64_t)average * (65536 - alpha);
  return (int32_t)((tmp0 + 32768) / 65536); //scale back to 32-bit (with rounding)
}

//here is a function that uses the averaging code
int32_t my_avg_func(void){
     static int32_t average = 0;
     int32_t adc_value;
     adc_value = read_the_adc_value();
     average = dsp_ema_i32(adc_value, average, DSP_EMA_I32_ALPHA(0.1));
     return average;
}
*/

/*
#define MAX_PRECISION	(10)
static const double rounders[MAX_PRECISION + 1] =
{
	0.5,				// 0
	0.05,				// 1
	0.005,				// 2
	0.0005,				// 3
	0.00005,			// 4
	0.000005,			// 5
	0.0000005,			// 6
	0.00000005,			// 7
	0.000000005,		// 8
	0.0000000005,		// 9
	0.00000000005		// 10
};

char * ftoa(double f, char * buf, int precision)
{
	char * ptr = buf;
	char * p = ptr;
	char * p1;
	char c;
	long intPart;

	// check precision bounds
	if (precision > MAX_PRECISION)
		precision = MAX_PRECISION;

	// sign stuff
	if (f < 0)
	{
		f = -f;
		*ptr++ = '-';
	}

	if (precision < 0)  // negative precision == automatic precision guess
	{
		if (f < 1.0) precision = 6;
		else if (f < 10.0) precision = 5;
		else if (f < 100.0) precision = 4;
		else if (f < 1000.0) precision = 3;
		else if (f < 10000.0) precision = 2;
		else if (f < 100000.0) precision = 1;
		else precision = 0;
	}

	// round value according the precision
	if (precision)
		f += rounders[precision];

	// integer part...
	intPart = f;
	f -= intPart;

	if (!intPart)
		*ptr++ = '0';
	else
	{
		// save start pointer
		p = ptr;

		// convert (reverse order)
		while (intPart)
		{
			*p++ = '0' + intPart % 10;
			intPart /= 10;
		}

		// save end pos
		p1 = p;

		// reverse result
		while (p > ptr)
		{
			c = *--p;
			*p = *ptr;
			*ptr++ = c;
		}

		// restore end pos
		ptr = p1;
	}

	// decimal part
	if (precision)
	{
		// place decimal point
		*ptr++ = '.';

		// convert
		while (precision--)
		{
			f *= 10.0;
			c = f;
			*ptr++ = '0' + c;
			f -= c;
		}
	}

	// terminating zero
	*ptr = 0;

	return buf;
}
*/

/* TREBUIE SA TESTEZ ACESTE FUNCTII RAPIDE DE APROXIMARE A ARCTANGENTEI
   POATE ESTE UNA SUFICIENT DE PRECISA

#include <math.h>
#include <stdio.h>

#ifndef M_PI_4
#define M_PI_4 (3.1415926535897932384626433832795/4.0)
#endif

double FastArcTan(double x) {
  return M_PI_4*x - x*(fabs(x) - 1)*(0.2447 + 0.0663*fabs(x));
}

#define A 0.0776509570923569
#define B -0.287434475393028
#define C (M_PI_4 - A - B)
#define FMT "% 16.8f"

double Fast2ArcTan(double x) {
  double xx = x * x;
  return ((A*xx + B)*xx + C)*x;
}

int main() {
  double mxe1 = 0, mxe2 = 0;
  double err1 = 0, err2 = 0;
  int n = 100;
  for (int i=-n;i<=n; i++) {
    double x = 1.0*i/n;
    double y = atan(x);
    double y_fast1 = FastArcTan(x);
    double y_fast2 = Fast2ArcTan(x);
    printf("%3d x:% .3f y:" FMT "y1:" FMT "y2:" FMT "\n", i, x, y, y_fast1, y_fast2);
    if (fabs(y_fast1 - y) > mxe1 ) mxe1  = fabs(y_fast1 - y);
    if (fabs(y_fast2 - y) > mxe2 ) mxe2  = fabs(y_fast2 - y);
    err1 += (y_fast1 - y)*(y_fast1 - y);
    err2 += (y_fast2 - y)*(y_fast2 - y);
  }
  printf("max error1: " FMT "sum sq1:" FMT "\n", mxe1, err1);
  printf("max error2: " FMT "sum sq2:" FMT "\n", mxe2, err2);
}

//#####################################################################################################

float squareRoot(float x)
{
  unsigned int i = *(unsigned int*) &x;

  // adjust bias
  i  += 127 << 23;
  // approximation of square root
  i >>= 1;

  return *(float*) &i;
}

*/

//#####################################################################################################

/*
//Sharing my code, it's a 6th degree polynomial, nothing special but rearranged to avoid pows.
//On Core i7 this is 2.3 times slower than standard implementation, although a bit faster for [0..2*PI] range.
//For an old processor this could be an alternative to standard sin/cos.

//    On [-1000..+1000] range with 0.001 step average error is: +/- 0.000011, max error: +/- 0.000060
//    On [-100..+100] range with 0.001 step average error is:   +/- 0.000009, max error: +/- 0.000034
//    On [-10..+10] range with 0.001 step average error is:     +/- 0.000009, max error: +/- 0.000030
//    Error distribution ensures there's no discontinuity.

const double PI          = 3.141592653589793;
const double HALF_PI     = 1.570796326794897;
const double DOUBLE_PI   = 6.283185307179586;
const double SIN_CURVE_A = 0.0415896;
const double SIN_CURVE_B = 0.00129810625032;

double cos1(double x) {
    if (x < 0) {
        int q = -x / DOUBLE_PI;
        q += 1;
        double y = q * DOUBLE_PI;
        x = -(x - y);
    }
    if (x >= DOUBLE_PI) {
        int q = x / DOUBLE_PI;
        double y = q * DOUBLE_PI;
        x = x - y;
    }
    int s = 1;
    if (x >= PI) {
        s = -1;
        x -= PI;
    }
    if (x > HALF_PI) {
        x = PI - x;
        s = -s;
    }
    double z = x * x;
    double r = z * (z * (SIN_CURVE_A - SIN_CURVE_B * z) - 0.5) + 1.0;
    if (r > 1.0) r = r - 2.0;
    if (s > 0) return r;
    else return -r;
}

double sin1(double x) {
    return cos1(x - HALF_PI);
}

*/

//#####################################################################################################

/*
//An approximation for the sine function that preserves the derivatives at multiples of 90 degrees
 * is given by this formula. The derivation is similar to Bhaskara I's sine approximation formula,
 *  but the constraints are to set the values and derivatives at 0, 90, and 180 degrees to that of
 *  the sine function. You can use this if you need the function to be smooth everywhere.

#define PI 3.141592653589793

double fast_sin(double x) {
    x /= 2 * PI;
    x -= (int) x;

    if (x <= 0.5) {
        double t = 2 * x * (2 * x - 1);
        return (PI * t) / ((PI - 4) * t - 1);
    }
    else {
        double t = 2 * (1 - x) * (1 - 2 * x);
        return -(PI * t) / ((PI - 4) * t - 1);
    }
}

double fast_cos(double x) {
    return fast_sin(x + 0.5 * PI);
}

//As for its speed, it at least outperforms the std::sin() function by an average of 0.3 microseconds per call. And the maximum absolute error is 0.0051.

*/

//#####################################################################################################

/*
I've not tested how fast this is, but I find it interesting nonetheless.

For x in [0,1], combining a zero degree Taylor approximation of sqrt((2-x)/3) with Hardy's (1959) approximation for cosine gives an okay approximation:

cos(x*pi/2) = 1 - x^2 / (0.81649658 + 0.183503 x)
where the coefficients in the denominator come from sqrt(2/3) and 1 - sqrt(2/3).

If you're willing to stretch to a first degree approximation of the square root then you get a really good approximation

cos(x*pi/2) = 1 - x^2 / (0.816497 - 0.0206207 x + 0.204124 x^2)
where the coefficients in the denomator are sqrt(2/3), 1-sqrt(2/3)-1/(2sqrt(6)) and 1/(2sqrt(6)).

And so on...
*/

//#####################################################################################################

/*
// Here is sine and cosine approximations in range [-pi,pi],
// which of the first is about eight times faster than std::sin() and second about seven
// times faster than std::cos() (compiled using GCC with options -O3 -ffast-math):


float fast_sine(float x){
    return 4.0f * (0.31830988618f * x * (1.0f - std::abs(0.31830988618f * x)));
}

float fast_cosine(float x){
   return 4.0f * (0.5f - 0.31830988618f * x) * (1.0f - std::abs(0.5f - 0.31830988618f * x)));
}
*/

//#####################################################################################################

/*Integer square root - Obtained from Stack Overflow (14/6/15):
 * http://stackoverflow.com/questions/1100090/looking-for-an-efficient-integer-square-root-algorithm-for-arm-thumb2
 * User: Gutskalk
 */
/*
uint16_t isqrt(uint32_t x)
{
	uint16_t res=0;
	uint16_t add= 0x8000;
	int i;
	for(i=0;i<16;i++)
	{
		uint16_t temp=res | add;
		uint32_t g2=temp*temp;
		if (x>=g2)
		{
			res=temp;
		}
		add>>=1;
	}
	return res;
}
*/

/*
// TREBUIE SA TESTEZ VITEZA ACESTEI FUNCTII OPTIMIZATA DOAR PENTRU VALORI REALE
// NU MAI FACE CALCULE SI PENTRU IMAGINARE, PENTRU CA NOI NU FOLOSIM NICIODATA
// NOI FACEM DOAR PE VALORI REALE
#include <math.h>
#include <stdio.h>

#define SWAP(a, b) tempr = (a); (a) = (b); (b) = tempr

// Input: nn is the number of points in the data and in the FFT,
//           nn must be a power of 2
// Input: data is sampled voltage v(0), v(1), v(2), ... v(nn-1)
// Output: data is complex FFT Re[V(0)], Im[V(0)], Re[V(1)], Im[V(1)], ...
// Note: Only real input is expected, output will still be complex.
void real_fft(float data[], unsigned long nn) {
    unsigned long n, mmax, m, j, istep, i;
    double wtemp, wr, wpr, wpi, wi, theta;
    double tempr, tempi;

    n = nn << 1;  // Total number of data points (2 * nn)
    j = 1;

    // Bit-reversal section
    for (i = 1; i < n; i += 2) {
        if (j > i) {   // Bit reversal condition
            SWAP(data[j - 1], data[i - 1]);  // Swap real parts
            SWAP(data[j], data[i]);          // Swap imaginary parts (which are 0)
        }
        m = n >> 1;
        while ((m >= 2) && (j > m)) {
            j = j - m;
            m = m >> 1;
        }
        j = j + m;
    }

    // Danielson-Lanczos section
    mmax = 2;
    while (n > mmax) {  // Loop executed log2(nn) times
        istep = mmax << 1;
        theta = -6.283185307179586476925286766559 / mmax; // 2 * PI / mmax
        wtemp = sin(0.5 * theta);
        wpr = -2.0 * wtemp * wtemp;  // Real part of the twiddle factor
        wpi = sin(theta);              // Imaginary part of the twiddle factor
        wr = 1.0;                      // Real part of the current twiddle factor
        wi = 0.0;                      // Imaginary part of the current twiddle factor

        for (m = 1; m < mmax; m += 2) {
            for (i = m; i <= n; i += istep) {
                j = i + mmax;
                tempr = wr * data[j - 1] - wi * data[j]; // FFT calculation
                tempi = wr * data[j] + wi * data[j - 1];
                data[j - 1] = data[i - 1] - tempr;      // Update real part
                data[j]   = data[i] - tempi;            // Update imaginary part
                data[i - 1] = data[i - 1] + tempr;      // Update real part
                data[i]   = data[i] + tempi;            // Update imaginary part
            }
            // Update twiddle factors
            wtemp = wr;
            wr = wr * wpr - wi * wpi + wr;
            wi = wi * wpr + wtemp * wpi + wi;
        }
        mmax = istep;  // Update mmax for the next iteration
    }
}

int main() {
    unsigned long nn = 4; // Number of data points (must be a power of 2)
    float data[] = {1.0, 0.0,  // First real sample
                    2.0, 0.0,  // Second real sample
                    3.0, 0.0,  // Third real sample
                    4.0, 0.0}; // Fourth real sample

    // Perform the FFT on the input data
    real_fft(data, nn);

    // Output the FFT results
    for (unsigned long i = 0; i < 2 * nn; i += 2) {
        printf("Re[%lu]: %f, Im[%lu]: %f\n", i / 2, data[i], i / 2, data[i + 1]);
    }

    return 0;
}
 */
